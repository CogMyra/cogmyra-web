// /public/guide/app.js
// Minimal, dependency-free wiring for the Guide page.
// Shows reply + (latency · tokens · version), pretty-prints logs,
// supports temperature slider, model select, and API base picker.
// Safe if some elements are missing: each hook is optional.

// ---------- tiny DOM helpers
const $ = (sel) => document.querySelector(sel);
const $$ = (sel) => Array.from(document.querySelectorAll(sel));

// ---------- state helpers
const LS = {
  get(key, fallback = null) {
    try {
      const v = localStorage.getItem(key);
      return v === null ? fallback : JSON.parse(v);
    } catch {
      return fallback;
    }
  },
  set(key, value) {
    try {
      localStorage.setItem(key, JSON.stringify(value));
    } catch {}
  },
};

// ---------- elements (all optional; we guard if missing)
const el = {
  sendBtn: $("#sendBtn"),
  userInput: $("#userInput"),
  reply: $("#reply"),
  logsPre: $("#logsPre") || $("#logs") || $("#logsJson"),
  temp: $("#temperature"),
  tempLabel: $("#tempLabel"),
  model: $("#model"),
  apiBaseInput: $("#apiBase"), // <input type="url"> OR <select id="apiBase">
  apiRadios: $$('input[name="apiBase"]'), // optional radio group
  refreshBtn: $("#refreshLogs"), // used for quick health check
  healthText: $("#apiStatus") || $("#health") || $("#healthText"),
};

// ---------- config
const DEFAULT_API = "https://cogmyra-api.onrender.com";
const API_KEY = "guide.apiBase";
const TEMP_KEY = "guide.temperature";
const MODEL_KEY = "guide.model";

// ---------- utilities
function getApiBase() {
  // 1) radio group has priority
  const checked = el.apiRadios.find((r) => r.checked);
  if (checked?.value) return checked.value.trim();

  // 2) explicit input/select
  const val = el.apiBaseInput?.value?.trim();
  if (val) return val;

  // 3) localStorage or default
  return LS.get(API_KEY, DEFAULT_API);
}

function setApiBaseUI(value) {
  // reflect into whichever controls exist
  if (el.apiBaseInput) el.apiBaseInput.value = value;
  if (el.apiRadios.length) {
    el.apiRadios.forEach((r) => (r.checked = r.value === value));
  }
  LS.set(API_KEY, value);
}

function getTemperature() {
  if (!el.temp) return null;
  const v = parseFloat(el.temp.value);
  return Number.isFinite(v) ? v : null;
}

function setTemperatureUI(v) {
  if (!el.temp) return;
  const clamped = Math.max(0, Math.min(2, Number(v) || 1.0));
  el.temp.value = clamped;
  if (el.tempLabel) el.tempLabel.textContent = clamped.toFixed(1);
  LS.set(TEMP_KEY, clamped);
}

function getModel() {
  if (!el.model) return "gpt-4.1";
  return el.model.value || "gpt-4.1";
}

function setModelUI(v) {
  if (!el.model) return;
  el.model.value = v;
  LS.set(MODEL_KEY, v);
}

function pretty(obj) {
  try {
    return JSON.stringify(obj, null, 2);
  } catch {
    return String(obj ?? "");
  }
}

function setReplyText(text) {
  if (!el.reply) return;
  if ("value" in el.reply) {
    el.reply.value = text;
  } else {
    el.reply.textContent = text;
  }
}

function setLogs(obj) {
  if (!el.logsPre) return;
  const text = pretty(obj);
  if ("value" in el.logsPre) {
    el.logsPre.value = text;
  } else {
    el.logsPre.textContent = text;
  }
}

function setBusy(busy) {
  if (el.sendBtn) {
    el.sendBtn.disabled = busy;
    el.sendBtn.textContent = busy ? "Sending…" : "Send";
  }
}

// ---------- network
async function healthCheck() {
  const base = getApiBase();
  const urls = [`${base}/api/healthz`, `${base}/api/health`]; // try both
  for (const url of urls) {
    try {
      const r = await fetch(url, { credentials: "include" });
      if (!r.ok) continue;
      const j = await r.json();
      const ok =
        j?.ok === "true" ||
        j?.status === "ok" ||
        j?.service === "cogmyra-api";
      const ver = j?.version || j?.build || j?.service || "";
      if (el.healthText) {
        el.healthText.textContent = `API: ${ok ? "online" : "degraded"} • ${
          ver || "unknown"
        }`;
      }
      return { ok, version: ver, raw: j };
    } catch {
      // try next
    }
  }
  if (el.healthText) el.healthText.textContent = "API: offline";
  return { ok: false };
}

async function sendMessage() {
  const base = getApiBase();
  const model = getModel();
  const temperature = getTemperature();
  const content = (el.userInput?.value || "").trim();

  if (!content) {
    setReplyText("(type a message first)");
    return;
  }

  setBusy(true);
  setReplyText("…");
  setLogs({ sending: true, model, temperature, content, base });

  try {
    const body = {
      sessionId: "guide",
      model,
      messages: [{ role: "user", content }],
    };
    if (typeof temperature === "number") body.temperature = temperature;

    const res = await fetch(`${base}/api/chat`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      credentials: "include", // harmless; server can ignore
      body: JSON.stringify(body),
    });

    // Handle non-2xx
    if (!res.ok) {
      const txt = await res.text().catch(() => "");
      throw new Error(
        `HTTP ${res.status} ${res.statusText}\n${txt || "(no body)"}`
      );
    }

    const data = await res.json();

    // Build meta suffix
    const meta = [];
    if (typeof data.latency_ms === "number") meta.push(`⏱ ${data.latency_ms} ms`);
    if (data.usage && data.usage.total_tokens != null)
      meta.push(`🔢 ${data.usage.total_tokens} tokens`);
    if (data.version) meta.push(`🧩 ${data.version}`);
    const suffix = meta.length ? `\n\n(${meta.join(" · ")})` : "";

    setReplyText((data.reply || "(no reply)") + suffix);
    setLogs(data);
  } catch (err) {
    const msg = (err && err.message) || String(err);
    setReplyText("Request failed.");
    setLogs({ error: msg });
    console.error(err);
  } finally {
    setBusy(false);
  }
}

// ---------- wiring
function wireButtons() {
  if (el.sendBtn) el.sendBtn.addEventListener("click", sendMessage);

  // Enter-to-send (Shift+Enter = newline)
  if (el.userInput) {
    el.userInput.addEventListener("keydown", (e) => {
      if (e.key === "Enter" && !e.shiftKey) {
        e.preventDefault();
        el.sendBtn?.click();
      }
    });
  }

  if (el.refreshBtn) {
    el.refreshBtn.addEventListener("click", () => {
      // fire & forget; healthCheck updates UI text
      healthCheck();
    });
  }
}

function wireTempLabel() {
  if (!el.temp) return;
  // init from LS or current input value
  const saved = LS.get(TEMP_KEY, null);
  setTemperatureUI(saved ?? el.temp.value ?? 1.0);

  el.temp.addEventListener("input", (e) => {
    setTemperatureUI(e.target.value);
  });
}

function wireModelPicker() {
  if (!el.model) return;
  const saved = LS.get(MODEL_KEY, null);
  if (saved) setModelUI(saved);

  el.model.addEventListener("change", (e) => {
    setModelUI(e.target.value);
  });
}

function wireApiPicker() {
  // prefer saved base, then current control value, then default
  const saved = LS.get(API_KEY, null);
  const initial = saved || getApiBase() || DEFAULT_API;
  setApiBaseUI(initial);

  // input/select
  if (el.apiBaseInput) {
    el.apiBaseInput.addEventListener("change", (e) => {
      const val = (e.target.value || "").trim() || DEFAULT_API;
      setApiBaseUI(val);
      // refresh health status when base changes
      healthCheck();
    });
  }

  // radios
  if (el.apiRadios.length) {
    el.apiRadios.forEach((r) =>
      r.addEventListener("change", (e) => {
        if (e.target.checked) {
          setApiBaseUI(e.target.value);
          healthCheck();
        }
      })
    );
  }
}

// ---------- init
function init() {
  wireButtons();
  wireTempLabel();
  wireModelPicker();
  wireApiPicker();
  // one-time health ping (mirrors your "$('#refreshLogs')?.click()" behavior)
  healthCheck();
}

document.addEventListener("DOMContentLoaded", init);
